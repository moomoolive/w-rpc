{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["export interface TransferValue<T> {\n    value: T\n    transferables: Transferable[]\n    __x_tdata__: true\n}\n\nexport const transferData = <T>(value: T, transferables: Transferable[]) => ({\n    value, \n    transferables,\n    __x_tdata__: true\n} as TransferValue<T>)\n\ntype RpcResponse<State extends object> = (\n    (() => any)\n    | ((param: any) => any)\n    | ((param: any, state: State) => any)\n)\n\ntype RpcOutboundAction = (\n    (() => any)\n    | ((param: any) => any)\n    | ((param: any, state: any) => any)\n)\n\ntype TerminalOutboundActions = {\n    readonly [key: string]: RpcOutboundAction\n}\n\nexport type TerminalActions<State extends object> = {\n    readonly [key: string]: RpcResponse<State>\n}\n\ntype TransferableFunctionReturn<T> = T extends TransferValue<infer ValueType>\n    ? ValueType\n    : T\n\nexport type RpcReturn<T> = T extends Promise<infer PromiseResolve>\n    ? Promise<TransferableFunctionReturn<PromiseResolve>>\n    : Promise<TransferableFunctionReturn<T>>\n\nexport type MessageContainer = {\n    handle: string\n    id: number\n    respondingTo: number\n    data: unknown\n}\n\ntype TerminalActionTuples<\n    T extends TerminalOutboundActions\n> = {\n    [key in keyof T]: Parameters<T[key]> extends ([param: any] | [param: any, state: any])\n        ? Parameters<T[key]>[0] extends (null | undefined)\n            ? [] : [param: Parameters<T[key]>[0]]\n        : []\n}\n\nexport const OUTBOUND_MESSAGE = -1\nexport const ERROR_RESPONSE_HANDLE = \"__x_rpc_error__\"\nexport const RESPONSE_HANDLE = \"__x_rpc_response__\"\n\nexport type MessageHandler = (event: {data: unknown, source: MessagableEntity} | {data: unknown}) => unknown\n\nexport type MessagableEntity = {\n    postMessage: (data: any, transferables: Transferable[]) => unknown\n    addEventListener: (event: \"message\", handler: MessageHandler) => unknown\n    removeEventListener: (event: \"message\", handler: MessageHandler) => unknown\n}\n\nexport type MessageTarget = {\n    postMessage: (data: any, transferables: Transferable[]) => unknown\n}\n\ntype RpcConfig<State extends object> = {\n    messageTarget: MessagableEntity\n    responses: TerminalActions<State>,\n    state: State\n}\n\nconst emptyTransferArray = [] as Transferable[]\n\nexport class wRpc<\n    RecipentActions extends TerminalOutboundActions,\n    State extends object = {},\n> {\n    static transfer = transferData\n\n    private idCount: number\n    private queue: Array<{\n        id: number\n        resolve: (data: any) => void\n        reject: (reason: any) => void\n    }>\n    private actionsIndex: Map<string, RpcResponse<State>>\n    private messageContainer: MessageContainer\n    private messageTarget: MessagableEntity\n    private messageHandlerRef: MessageHandler\n    \n    state: State\n\n    constructor({\n        responses,\n        messageTarget,\n        state\n    }: RpcConfig<State>) {\n        const self = this\n        this.state = state\n        this.messageTarget = messageTarget\n        this.messageHandlerRef = (event) => {\n            self.consumeMessage(\n                event.data as MessageContainer,\n                (\"source\" in event) ? event.source || null : null\n            )\n        }\n        this.messageTarget.addEventListener(\"message\", self.messageHandlerRef)\n        \n        this.idCount = 0\n        this.queue = []\n        this.messageContainer = {\n            handle: \"\",\n            id: -1,\n            respondingTo: OUTBOUND_MESSAGE,\n            data: null\n        }\n\n        this.actionsIndex = new Map()\n        const actionKeys = Object.keys(responses)\n        for (let index = 0; index < actionKeys.length; index++) {\n            const element = actionKeys[index]\n            this.actionsIndex.set(element, responses[element])\n        }\n    }\n\n    cleanup(): boolean {\n        this.messageTarget.removeEventListener(\"message\", this.messageHandlerRef)\n        return true\n    }\n\n    replaceMessageTarget(messageTarget: MessagableEntity): boolean {\n        const self = this\n        this.cleanup()\n        this.messageTarget = messageTarget\n        this.messageTarget.addEventListener(\"message\", (event) => {\n            self.consumeMessage(\n                event.data as MessageContainer,\n                (\"source\" in event) ? event.source || null : null\n            )\n        })\n        return true\n    }\n\n    async executeWithSource<T extends keyof RecipentActions>(\n        name: T & string,\n        source: MessageTarget,\n        data: Parameters<RecipentActions[T]>[0] extends undefined ? null : Parameters<RecipentActions[T]>[0], \n        transferables?: Transferable[]\n    ) {\n        return await this.outboundMessage(\n            source, name, data, transferables\n        ) as RpcReturn<ReturnType<RecipentActions[T]>>\n    }\n\n    execute<T extends keyof RecipentActions>(\n        name: T & string,\n        ...args: TerminalActionTuples<RecipentActions>[T] extends [params: any]\n            ? (\n                [param: TerminalActionTuples<RecipentActions>[T][0]]\n                | [param: TerminalActionTuples<RecipentActions>[T][0], transferables: Transferable[]]\n            )\n            : []\n    ): Promise<RpcReturn<ReturnType<RecipentActions[T]>>>\n    async execute<T extends keyof RecipentActions>(\n        name: T & string,\n        param: null = null ,\n        transferables: Transferable[] = []\n    ): Promise<RpcReturn<ReturnType<RecipentActions[T]>>> {\n        return await this.outboundMessage(\n            this.messageTarget, name, param, transferables\n        ) as RpcReturn<ReturnType<RecipentActions[T]>>\n    }\n\n    private outboundMessage(\n        source: MessageTarget,\n        handle: string,\n        data: unknown = null,\n        transferables: Transferable[] = emptyTransferArray\n    ) {\n        const self = this\n        return new Promise((resolve, reject) => {\n            const id = this.idCount\n            self.queue.push({id, resolve, reject})\n            self.transferMessage(\n                source, \n                handle, \n                OUTBOUND_MESSAGE, \n                data, \n                transferables\n            )\n        })\n    }\n\n    private responseMessage(\n        source: MessagableEntity | null,\n        respondingTo: number, \n        data: unknown\n    ) {\n        const transfer = (\n            typeof data === \"object\"\n            && data !== null\n            && (data as TransferValue<unknown>).__x_tdata__ === true\n        )\n        this.transferMessage(\n            source,\n            RESPONSE_HANDLE, \n            respondingTo, \n            transfer ? (data as TransferValue<any>).value : data, \n            transfer ? (data as TransferValue<any>).transferables : emptyTransferArray\n        )\n    }\n\n    private errorResponseMessage(\n        source: MessagableEntity | null,\n        respondingTo: number, \n        errorMessage: string\n    ) {\n        this.transferMessage(\n            source,\n            ERROR_RESPONSE_HANDLE, \n            respondingTo, \n            errorMessage\n        )\n    }\n\n    private transferMessage(\n        source: MessageTarget | null,\n        handle: string,\n        respondingTo: number, \n        data: unknown,\n        transferables?: Transferable[]\n    ) {\n        const {messageContainer} = this\n        const id = this.idCount++\n        messageContainer.handle = handle\n        messageContainer.respondingTo = respondingTo\n        messageContainer.data = data ?? null\n        messageContainer.id = id\n        const entity = source || this.messageTarget\n        entity.postMessage(\n            messageContainer, \n            transferables || emptyTransferArray\n        )\n        return id\n    }\n\n    private async consumeMessage(\n        message: MessageContainer,\n        source: MessagableEntity | null\n    ) {\n        if (message === null || typeof message !== \"object\") {\n            console.warn(\"recieved message was not an object ignoring message\", message)\n            return\n        }\n\n        if (\n            message.handle === RESPONSE_HANDLE\n            || message.handle === ERROR_RESPONSE_HANDLE\n        ) {\n            const {queue} = this\n            for (let index = 0; index < queue.length; index++) {\n                const element = queue[index]\n                if (message.respondingTo === element.id) {\n                    if (message.handle === ERROR_RESPONSE_HANDLE) {\n                        element.reject(message.data)\n                    } else {\n                        element.resolve(message.data)\n                    }\n                    queue.splice(index, 1)\n                    return\n                }\n            }\n            console.warn(\"incoming response doesn't map to any queued message. ignoring\", message)\n            return\n        }\n\n        if (!this.actionsIndex.has(message.handle)) {\n            this.errorResponseMessage(\n                source,\n                message.id,\n                `attempted to call non-existent handler \"${message.handle}\"`\n            )\n            return\n        }\n\n        if (\n            message.respondingTo === OUTBOUND_MESSAGE \n            && message.data !== undefined\n        ) {\n            const handler = this.actionsIndex.get(message.handle)!\n            try {\n                const data = await handler(message.data, this.state) ?? null\n                this.responseMessage(source, message.id, data)\n            } catch (err) {\n                this.errorResponseMessage(\n                    source,\n                    message.id,\n                    `rpc function \"${message.handle}\" encountered an exception. ${err} ${(err as Error)?.stack || \"no-stack\"}`\n                )\n            }\n            return\n        }\n        console.warn(\"incoming message is neither a response to a previous message or a request to perform an action. ignoring message\", message)\n        return\n    }\n\n    addResponses(\n        responses: TerminalActions<State>, \n        {allowOverwrite = false} = {}\n    ): boolean {\n        const actionKeys = Object.keys(responses)\n        let added = false\n        for (let index = 0; index < actionKeys.length; index++) {\n            const element = actionKeys[index]\n            if (!allowOverwrite && this.actionsIndex.has(element)) {\n                continue\n            }\n            added = true\n            this.actionsIndex.set(element, responses[element])\n        }\n        return added\n    }\n}\n"],
  "mappings": "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",
  "names": ["value", "transferables", "emptyTransferArray", "responses", "messageTarget", "state", "self", "event", "actionKeys", "index", "element", "name", "source", "data", "param", "handle", "resolve", "reject", "id", "respondingTo", "transfer", "errorMessage", "messageContainer", "message", "queue", "handler", "err", "allowOverwrite", "added"]
}
