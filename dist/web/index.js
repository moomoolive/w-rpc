"use strict";export const transferData=(l,e)=>({value:l,transferables:e,__x_tdata__:!0}),OUTBOUND_MESSAGE=-1,ERROR_RESPONSE_HANDLE="__x_rpc_error__",RESPONSE_HANDLE="__x_rpc_response__";const o=[];export class wRpc{static transfer=transferData;idCount;queue;actionsIndex;messageContainer;messageTarget;messageHandlerRef;state;constructor({responses:e,messageTarget:s,state:n}){const t=this;this.state=n,this.messageTarget=s,this.messageHandlerRef=a=>{t.consumeMessage(a.data,"source"in a&&a.source||null)},this.messageTarget.addEventListener("message",t.messageHandlerRef),this.idCount=0,this.queue=[],this.messageContainer={handle:"",id:-1,respondingTo:-1,data:null},this.actionsIndex=new Map;const r=Object.keys(e);for(let a=0;a<r.length;a++){const i=r[a];this.actionsIndex.set(i,e[i])}}cleanup(){return this.messageTarget.removeEventListener("message",this.messageHandlerRef),!0}replaceMessageTarget(e){const s=this;return this.cleanup(),this.messageTarget=e,this.messageTarget.addEventListener("message",n=>{s.consumeMessage(n.data,"source"in n&&n.source||null)}),!0}async executeWithSource(e,s,n,t){return await this.outboundMessage(s,e,n,t)}async execute(e,s=null,n=[]){return await this.outboundMessage(this.messageTarget,e,s,n)}outboundMessage(e,s,n=null,t=o){const r=this;return new Promise((a,i)=>{const u=this.idCount;r.queue.push({id:u,resolve:a,reject:i}),r.transferMessage(e,s,-1,n,t)})}responseMessage(e,s,n){const t=typeof n=="object"&&n!==null&&n.__x_tdata__===!0;this.transferMessage(e,RESPONSE_HANDLE,s,t?n.value:n,t?n.transferables:o)}errorResponseMessage(e,s,n){this.transferMessage(e,ERROR_RESPONSE_HANDLE,s,n)}transferMessage(e,s,n,t,r){const{messageContainer:a}=this,i=this.idCount++;return a.handle=s,a.respondingTo=n,a.data=t??null,a.id=i,(e||this.messageTarget).postMessage(a,r||o),i}async consumeMessage(e,s){if(e===null||typeof e!="object"){console.warn("recieved message was not an object ignoring message",e);return}if(e.handle===RESPONSE_HANDLE||e.handle===ERROR_RESPONSE_HANDLE){const{queue:n}=this;for(let t=0;t<n.length;t++){const r=n[t];if(e.respondingTo===r.id){e.handle===ERROR_RESPONSE_HANDLE?r.reject(e.data):r.resolve(e.data),n.splice(t,1);return}}console.warn("incoming response doesn't map to any queued message. ignoring",e);return}if(!this.actionsIndex.has(e.handle)){this.errorResponseMessage(s,e.id,`attempted to call non-existent handler "${e.handle}"`);return}if(e.respondingTo===-1&&e.data!==void 0){const n=this.actionsIndex.get(e.handle);try{const t=await n(e.data,this.state)??null;this.responseMessage(s,e.id,t)}catch(t){this.errorResponseMessage(s,e.id,`rpc function "${e.handle}" encountered an exception. ${t} ${t?.stack||"no-stack"}`)}return}console.warn("incoming message is neither a response to a previous message or a request to perform an action. ignoring message",e)}addResponses(e,{allowOverwrite:s=!1}={}){const n=Object.keys(e);let t=!1;for(let r=0;r<n.length;r++){const a=n[r];!s&&this.actionsIndex.has(a)||(t=!0,this.actionsIndex.set(a,e[a]))}return t}}
//# sourceMappingURL=index.js.map
